{
  "version": 3,
  "sources": ["../../embla-carousel-auto-scroll/src/components/Options.ts", "../../embla-carousel-auto-scroll/src/components/utils.ts", "../../embla-carousel-auto-scroll/src/components/AutoScroll.ts"],
  "sourcesContent": ["import { CreateOptionsType } from 'embla-carousel'\n\nexport type RootNodeType =\n  | null\n  | ((emblaRoot: HTMLElement) => HTMLElement | null)\n\nexport type OptionsType = CreateOptionsType<{\n  direction: 'forward' | 'backward'\n  speed: number\n  startDelay: number\n  playOnInit: boolean\n  stopOnFocusIn: boolean\n  stopOnInteraction: boolean\n  stopOnMouseEnter: boolean\n  rootNode: RootNodeType\n}>\n\nexport const defaultOptions: OptionsType = {\n  direction: 'forward',\n  speed: 2,\n  startDelay: 1000,\n  active: true,\n  breakpoints: {},\n  playOnInit: true,\n  stopOnFocusIn: true,\n  stopOnInteraction: true,\n  stopOnMouseEnter: false,\n  rootNode: null\n}\n", "import { EmblaCarouselType } from 'embla-carousel/components/EmblaCarousel'\nimport { RootNodeType } from './Options'\n\nexport function getAutoScrollRootNode(\n  emblaApi: EmblaCarouselType,\n  rootNode: RootNodeType\n): HTMLElement {\n  const emblaRootNode = emblaApi.rootNode()\n  return (rootNode && rootNode(emblaRootNode)) || emblaRootNode\n}\n", "import { OptionsType, defaultOptions } from './Options'\nimport { getAutoScrollRootNode } from './utils'\nimport {\n  CreatePluginType,\n  OptionsHandlerType,\n  EmblaCarouselType,\n  EngineType,\n  ScrollBodyType\n} from 'embla-carousel'\n\ndeclare module 'embla-carousel' {\n  interface EmblaPluginsType {\n    autoScroll: AutoScrollType\n  }\n\n  interface EmblaEventListType {\n    autoScrollPlay: 'autoScroll:play'\n    autoScrollStop: 'autoScroll:stop'\n  }\n}\n\nexport type AutoScrollType = CreatePluginType<\n  {\n    play: (delay?: number) => void\n    stop: () => void\n    reset: () => void\n    isPlaying: () => boolean\n  },\n  OptionsType\n>\n\nexport type AutoScrollOptionsType = AutoScrollType['options']\n\nfunction AutoScroll(userOptions: AutoScrollOptionsType = {}): AutoScrollType {\n  let options: OptionsType\n  let emblaApi: EmblaCarouselType\n  let destroyed: boolean\n  let startDelay: number\n  let timerId = 0\n  let autoScrollActive = false\n  let mouseIsOver = false\n  let defaultScrollBehaviour: ScrollBodyType\n\n  function init(\n    emblaApiInstance: EmblaCarouselType,\n    optionsHandler: OptionsHandlerType\n  ): void {\n    emblaApi = emblaApiInstance\n\n    const { mergeOptions, optionsAtMedia } = optionsHandler\n    const optionsBase = mergeOptions(defaultOptions, AutoScroll.globalOptions)\n    const allOptions = mergeOptions(optionsBase, userOptions)\n    options = optionsAtMedia(allOptions)\n\n    if (emblaApi.scrollSnapList().length <= 1) return\n\n    startDelay = options.startDelay\n    destroyed = false\n    defaultScrollBehaviour = emblaApi.internalEngine().scrollBody\n\n    const { eventStore } = emblaApi.internalEngine()\n    const isDraggable = !!emblaApi.internalEngine().options.watchDrag\n    const root = getAutoScrollRootNode(emblaApi, options.rootNode)\n\n    if (isDraggable) {\n      emblaApi.on('pointerDown', pointerDown)\n    }\n\n    if (isDraggable && !options.stopOnInteraction) {\n      emblaApi.on('pointerUp', pointerUp)\n    }\n\n    if (options.stopOnMouseEnter) {\n      eventStore.add(root, 'mouseenter', mouseEnter)\n    }\n\n    if (options.stopOnMouseEnter && !options.stopOnInteraction) {\n      eventStore.add(root, 'mouseleave', mouseLeave)\n    }\n\n    if (options.stopOnFocusIn) {\n      emblaApi.on('slideFocusStart', stopAutoScroll)\n    }\n\n    if (options.stopOnFocusIn && !options.stopOnInteraction) {\n      eventStore.add(emblaApi.containerNode(), 'focusout', startAutoScroll)\n    }\n\n    if (options.playOnInit) startAutoScroll()\n  }\n\n  function destroy(): void {\n    emblaApi\n      .off('pointerDown', pointerDown)\n      .off('pointerUp', pointerUp)\n      .off('slideFocusStart', stopAutoScroll)\n      .off('settle', settle)\n\n    stopAutoScroll()\n    destroyed = true\n    autoScrollActive = false\n  }\n\n  function startAutoScroll(): void {\n    if (destroyed) return\n    if (autoScrollActive) return\n    emblaApi.emit('autoScroll:play')\n\n    const engine = emblaApi.internalEngine()\n    const { ownerWindow } = engine\n\n    timerId = ownerWindow.setTimeout(() => {\n      engine.scrollBody = createAutoScrollBehaviour(engine)\n      engine.animation.start()\n    }, startDelay)\n\n    autoScrollActive = true\n  }\n\n  function stopAutoScroll(): void {\n    if (destroyed) return\n    if (!autoScrollActive) return\n    emblaApi.emit('autoScroll:stop')\n\n    const engine = emblaApi.internalEngine()\n    const { ownerWindow } = engine\n\n    engine.scrollBody = defaultScrollBehaviour\n    ownerWindow.clearTimeout(timerId)\n    timerId = 0\n\n    autoScrollActive = false\n  }\n\n  function createAutoScrollBehaviour(engine: EngineType): ScrollBodyType {\n    const {\n      location,\n      previousLocation,\n      offsetLocation,\n      target,\n      scrollTarget,\n      index,\n      indexPrevious,\n      limit: { reachedMin, reachedMax, constrain },\n      options: { loop }\n    } = engine\n    const directionSign = options.direction === 'forward' ? -1 : 1\n    const noop = (): ScrollBodyType => self\n\n    let bodyVelocity = 0\n    let scrollDirection = 0\n    let rawLocation = location.get()\n    let rawLocationPrevious = 0\n    let hasSettled = false\n\n    function seek(): ScrollBodyType {\n      let directionDiff = 0\n\n      previousLocation.set(location)\n\n      bodyVelocity = directionSign * options.speed\n      rawLocation += bodyVelocity\n      location.add(bodyVelocity)\n      target.set(location)\n\n      directionDiff = rawLocation - rawLocationPrevious\n      scrollDirection = Math.sign(directionDiff)\n      rawLocationPrevious = rawLocation\n\n      const currentIndex = scrollTarget.byDistance(0, false).index\n\n      if (index.get() !== currentIndex) {\n        indexPrevious.set(index.get())\n        index.set(currentIndex)\n        emblaApi.emit('select')\n      }\n\n      const reachedEnd =\n        options.direction === 'forward'\n          ? reachedMin(offsetLocation.get())\n          : reachedMax(offsetLocation.get())\n\n      if (!loop && reachedEnd) {\n        hasSettled = true\n        const constrainedLocation = constrain(location.get())\n        location.set(constrainedLocation)\n        target.set(location)\n        stopAutoScroll()\n      }\n\n      return self\n    }\n\n    const self: ScrollBodyType = {\n      direction: () => scrollDirection,\n      duration: () => -1,\n      velocity: () => bodyVelocity,\n      settled: () => hasSettled,\n      seek,\n      useBaseFriction: noop,\n      useBaseDuration: noop,\n      useFriction: noop,\n      useDuration: noop\n    }\n    return self\n  }\n\n  function pointerDown(): void {\n    if (!mouseIsOver) stopAutoScroll()\n  }\n\n  function pointerUp(): void {\n    if (!mouseIsOver) startAutoScrollOnSettle()\n  }\n\n  function mouseEnter(): void {\n    mouseIsOver = true\n    stopAutoScroll()\n  }\n\n  function mouseLeave(): void {\n    mouseIsOver = false\n    startAutoScroll()\n  }\n\n  function settle(): void {\n    emblaApi.off('settle', settle)\n    startAutoScroll()\n  }\n\n  function startAutoScrollOnSettle(): void {\n    emblaApi.on('settle', settle)\n  }\n\n  function play(startDelayOverride?: number): void {\n    if (typeof startDelayOverride !== 'undefined') {\n      startDelay = startDelayOverride\n    }\n    startAutoScroll()\n  }\n\n  function stop(): void {\n    if (autoScrollActive) stopAutoScroll()\n  }\n\n  function reset(): void {\n    if (autoScrollActive) {\n      stopAutoScroll()\n      startAutoScrollOnSettle()\n    }\n  }\n\n  function isPlaying(): boolean {\n    return autoScrollActive\n  }\n\n  const self: AutoScrollType = {\n    name: 'autoScroll',\n    options: userOptions,\n    init,\n    destroy,\n    play,\n    stop,\n    reset,\n    isPlaying\n  }\n  return self\n}\n\ndeclare namespace AutoScroll {\n  let globalOptions: AutoScrollOptionsType | undefined\n}\n\nAutoScroll.globalOptions = undefined\n\nexport default AutoScroll\n"],
  "mappings": "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",
  "names": ["defaultOptions", "direction", "speed", "startDelay", "active", "breakpoints", "playOnInit", "stopOnFocusIn", "stopOnInteraction", "stopOnMouseEnter", "rootNode", "getAutoScrollRootNode", "emblaApi", "emblaRootNode", "AutoScroll", "userOptions", "options", "destroyed", "timerId", "autoScrollActive", "mouseIsOver", "defaultScrollBehaviour", "init", "emblaApiInstance", "optionsHandler", "mergeOptions", "optionsAtMedia", "optionsBase", "globalOptions", "allOptions", "scrollSnapList", "length", "internalEngine", "scrollBody", "eventStore", "isDraggable", "watchDrag", "root", "on", "pointerDown", "pointerUp", "add", "mouseEnter", "mouseLeave", "stopAutoScroll", "containerNode", "startAutoScroll", "destroy", "off", "settle", "emit", "engine", "ownerWindow", "setTimeout", "createAutoScrollBehaviour", "animation", "start", "clearTimeout", "location", "previousLocation", "offsetLocation", "target", "scrollTarget", "index", "indexPrevious", "limit", "reachedMin", "reachedMax", "constrain", "loop", "directionSign", "noop", "self", "bodyVelocity", "scrollDirection", "rawLocation", "get", "rawLocationPrevious", "hasSettled", "seek", "directionDiff", "set", "Math", "sign", "currentIndex", "byDistance", "reachedEnd", "constrainedLocation", "duration", "velocity", "settled", "useBaseFriction", "useBaseDuration", "useFriction", "useDuration", "startAutoScrollOnSettle", "play", "startDelayOverride", "stop", "reset", "isPlaying", "name", "undefined"]
}
